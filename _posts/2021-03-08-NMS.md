---
layout: post
title: Non-Maximum Suppression(NMS)란
use_math: False
categories: etc
---





object detectior가 예측한 bounding box중에서 정확한 bounding box를 선택하도록 하는 기법이다.


대표적으로 YOLO에 NMS기법이 적용되어 있다.


![NMS_1](/public/images/2021-03-08-NMS-1.png)




## NMS 의사코드


![NMS_1](/public/images/2021-03-08-NMS-2.png)




## 알고리즘


1. Detected 된 bounding box 별로 Confidence threshold 이하의 bounding box는 제거한다.
2. 가장 높은 confidence score를 가진 box 순으로 내림차순 정렬하고 아래 로직을 모든 box에 순차적으로 적용
   1. 가장 높은 confience score를 가진 box와 곂치는 다른 box를 모두 조사하여 IOU가 특정 threshold 이상인 box를 모두 제거. 즉 IOU가 일정 이상인 boundingbox는 동일한 물체를 detect 했다고 판단하고 곂치는 box를 제거해 주는 과정
3. 남아 있는 box만 선택

## 코드 구현 
</br>
위의 과정을 통해 최대한 하나의 Object에 하나의 Detection box만이 존재하도록 만들게 된다. 이 아이디어는 이미 Tensorflow에 `tf.image.non_max_suppression` 으로 구현되어있기에 우리가 직접 구현할 필요는 없지만 보다 확실한 이해를 위해서 다음과 같이 Python code로 구현해볼 수 있다.

```python

def nms(boxes, probs, threshold):
  """Non-Maximum supression.
  Args:
    boxes: array of [cx, cy, w, h] (center format)
    probs: array of probabilities
    threshold: two boxes are considered overlapping if their IOU is largher than
        this threshold
    form: 'center' or 'diagonal'
  Returns:
    keep: array of True or False.
  """
 
  order = probs.argsort()[::-1]
  keep = [True]*len(order)
 
  for i in range(len(order)-1):
    ovps = batch_iou(boxes[order[i+1:]], boxes[order[i]])
    for j, ov in enumerate(ovps):
      if ov > threshold:
        keep[order[j+i+1]] = False
  return keep
```



[참고 자료] 

https://go-hard.tistory.com/25

https://dyndy.tistory.com/275 *

https://donggoolosori.github.io/2020/10/14/dlcv-nms/ * 

https://towardsdatascience.com/non-maximum-suppression-nms-93ce178e177c


---